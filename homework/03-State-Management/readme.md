# Домашнее задание #3. Flux-like паттерн управления состоянием (а так же удаление и редактирование пользовательского контента)

Минна конничи ва!

Сегодня нам (= вам) предстоит сделать много всего, пожалуй.\
Поэтому, как говорится, _without further ado_, приступим к разбору
~~по частям~~ всего того, что вам нужно (будет) сделать.

Итак, таски на это домашнее задание (все они подразумевают, что
у вас есть TODOApp в каком-то виде, если у вас его нет, то вам
[сюда][todos-solution]):
1. Изменить архитектуру приложения, учитывая, что как и у любого
   уважающего себя списка дел, у нашего (вашего) тоже должна быть
   возможность помечать дела как выполненные (обозначать это
   правильнее всего зачёркиванием + блёклым цветом шрифта);
2. Запилить возможность редактировать текст тудушки и сносить её ко
   всем матерям, или, если проще и более официально, удалять её
   из списка;
3. Настроить синхронизацию всех этих изменений с сервером и, если
   вы по какой-то причине не успели сделать это на паре (ну или
   у вас банально не было возможности это сделать на паре),
   настроить синзронизацию всех дел + непосредственно их
   добавления;
4. Убедиться, что за всей работой вашего приложения стоит система
   управления состоянием.

Итак, обо всём по порядку, поехали.

## 1. Работа с сервером 101.

Подробно расписывать принцип работы AJAX (т.е. технологии
`XMLHTTPRequest`) я не буду, так как я вскользь уже говорил
об этом на паре, причём это скорее всего спутает и так витиеватый
стиль повествования этого ридми, поэтому перейдём сразу к разбору
сниппета, который опишет, как же, собственно, это всё происходит.
Это будет как некий рекап того, что мы уже изучили.

```javascript
// создаём объект XHR-запроса
const xhr = new XMLHTTPRequest()

// запрос будет выполняться на адрес URL, используя метод METHOD
// на данный момент нас интересуют методы GET, POST, PUT, DELETE
// в методах HTTP-запросов на самом деле мало разницы, она скорее
// семантическая. Единственное, что важно знать -- GET обычно не
// содержит какого-либо тела запроса, так как обычно используется
// для запроса какой-то информации с сервера, а всё остальное
// обычно несёт в своём теле какую-то дополнительную информацию,
// важную для сервера (и корректного выполнения запроса).
xhr.open('<METHOD>', '<URL>')

xhr.onreadystatechange = () => {
  // тут начинается самое интересное.
  // onreadystatechange содержит функцию, по сути, обработчик
  // события, который будет вызван, когда изменится readyState
  // (состояние готовности) запроса. Здесь мы можем наконец-то
  // обрабатывать данные, которые приходят в ответ на запрос.
  // обратите внимание, что данный обработчик будет выполнен
  // асинхронно, как только данные с сервера будут 
  // получены. Поэтому имеет мало смысла (не имеет
  // вообще) объявлять здесь какие-то переменные и пытаться
  // работать с ними ВНЕ этой функции.

  // Проверим, что запрос завершился и завершился успешно (с
  // HTTP-статусом 200, означающим, что всё окей)
  if (xhr.readyState === XMLHTTPRequest.DONE && xhr.status === 200) {
    // можно парсить ответ сервера (в данном случае это, допустим,
    // JSON-строка) и делать с ним всё, что вздумается

    console.log(JSON.parse(xhr.responseText))
  }
}

// непосредственно отправляем запрос, побуждая браузер его
// выполнить. REQUEST_BODY нужен только для не-GET запросов.
xhr.send('<REQUEST_BODY>')
```

Отлично. Теперь краткая справка по тому, как работает сервер
для этого таска, на какие пути и на какие методы он реагирует.

1. Хотите работать с этим сервером &mdash; сначала
   зарегистрируйтесь. Заходите через браузер по адресу
   `http://brotheroftux.org:8080/register/<SOMETHING_UNIQUE>`, 
   где SOMETHING_UNIQUE &mdash; любая достаточно уникальная
   по вашему мнению строка, в ответ получаете хеш, который
   в будущем можете использовать для запросов к серверу от
   своего имени.
2. `GET http://brotheroftux.org:8080/todos/:hash`, где `:hash` 
   &mdash; ваш уникальный хеш, выдаст вам список всех туду
   этого пользователя в JSON-формате:

   ```json
   {
     "response": [...]
   }
   ```

   где в поле `response` содержится массив всех туду текущего
   пользователя, причём каждый объект этого массива имеет
   следующий формат:

   ```json
   {
     "text": "СДЕЛАЙ ЧТО-НИБУДЬ УЖЕ",
     "done": false
   }
   ```

   Если пользователя с таким значением хеша не существует в базе
   данных, то ответ будет иметь следующий формат:

   ```json
   {
     "error": "No such hash in the database"
   }
   ```
3. `POST http://brotheroftux.org:8080/todos/:hash` добавляет туду
   к списку дел пользователя. На вход сервер ждёт следующий формат
   запроса:

   ```json
   {
     "text": "ПРОСТО СДЕЛАЙ",
     "done": false
   }
   ```

   где `done` &mdash; опциональный булевый флаг (в запрос включать
   его не обязательно, по умолчанию он равен `false`).

   При несоответствии запроса формату будет возвращена ошибка:

   ```json
   {
     "error": "Invalid request format"
   }
   ```

   Иначе будет возвращён ответ следующего вида:

   ```json
   {
     "response": "ok"
   }
   ```
4. `PUT http://brotheroftux.org:8080/todos/:hash` редактирует тудушку,
   имеющую заданный индекс. Формат запроса:

   ```json
   {
     "index": 0,
     "text": "Новый текст",
     "done": true
   }
   ```

   где `text` и `done` являются опциональными полями.

   При несоответствии запроса формату будет возвращена ошибка:

   ```json
   {
     "error": "Invalid request format"
   }
   ```

   Иначе будет возвращён ответ следующего вида:

   ```json
   {
     "response": "ok"
   }
   ```
5. `DELETE http://brotheroftux.org:8080/todos/:hash` удаляет дело из массива
   по заданному индексу. Формат запроса:

   ```json
   {
     "index": 0
   }
   ```

   При несоответствии запроса формату будет возвращена ошибка:

   ```json
   {
     "error": "Invalid request format"
   }
   ```

   Иначе будет возвращён ответ следующего вида:

   ```json
   {
     "response": "ok"
   }
   ```

Форматы запросов, как они описаны в коде сервера:

```javascript
const schemas = {}

schemas.deletionSchema = {
  index: {
    type: 'number',
    optional: false
  }
}

schemas.additionSchema = {
  text: {
    type: 'string',
    optional: false
  },

  done: {
    type: 'boolean',
    optional: true
  }
}

schemas.editingSchema = {
  index: {
    type: 'number',
    optional: false
  },

  text: {
    type: 'string',
    optional: true
  },

  done: {
    type: 'boolean',
    optional: true
  }
}

module.exports = schemas
```

## 2. State Management 101

Итак, пришло время немного всё же разобраться в модели управления
состоянием, которую я пытался описать на паре.

Допустим, что у нас есть простое приложение, которое состоит
из счётчика и кнопки. По нажатии на кнопку значение счётчика
увеличивается.

Что такое _состояние_ приложения? Это все данные, которыми это
приложение может оперировать в данный момент, более того,
это все данные, которые необходимы этому приложению в этот же
момент времени.

Итак, начнём построение модуля состояния для этого примера.
Это будет один объект.

```javascript
const StateModule = {

}
```

Объект состояния хранит в себе (ВАУ!) состояние.

```javascript
const StateModule = {
  state: {}
}
```

Пока что это пустой объект, но так не сгодится. Что же является
состоянием для нашего игрушечного примера?

<details><summary>спойлер</summary>
Значение счётчика. 
</details>

```javascript
const StateModule = {
  state: {
    count: 0
  }
}
```

Окей, это всё, конечно, прикольно, но сейчас это не несёт никакой
смысловой нагрузки. Да, мы просто храним значение счётчика внутри
объекта, который инкапсулирует собой состояние, и что дальше?
Чем это отличается от хранения этого же значения просто в
глобальной переменной?

Куда нас заведёт дорожка этой абстракции?

Итак, пришло время ввести ещё одно понятие: мутация. Что такое
мутация? Мутация &mdash; это максимально атомарная (неразбивная)
операция, которую можно выполнить над состоянием. Всё приложение
и все преобразования данных, проходящие в нём, можно описать как
набор мутаций.

Что является мутациями для нашего игрушечного примера?

Увеличение значения счётчика. Это единственная ситуация,
когда состояние вообще хоть как-нибудь изменится.

Опишем эту мутацию. Будем учитывать, что в этом паттерне мутация
&mdash; это функция, старающаяся не создавать сайд-эффектов
помимо изменения самого состояния, более того, это функция,
принимающая текущее состояние (и, возможно, второй дополнительный
параметр, но в данном случае он нам не нужен)

```javascript
const StateModule = {
  state: {
    count: 0
  },

  mutations: {
    increment: state => state.count++
  }
}
```

Осталось написать возможность эти (эту) мутации применять на
состояние. Этой возможностью будет функция `commit`.

```javascript
const StateModule = {
  state: {
    count: 0
  },

  mutations: {
    increment: state => state.count++
  },

  commit (mutation, payload) {
    // payload -- опциональный второй аргумент мутации, если
    // он нужен; в данном случае вообще говоря он не нужен.

    this.mutations[mutation](this.state, payload)
  }
}
```

Отлично. Однако это всё ещё имеет мало смысла. Состояние и так
можно изменять, не описывая мутации. Эта абстракция, конечно,
приводит в порядок архитектуру приложения и централизованно
описывает её, но пришло время рассказать о настоящих payoff-ах
централизованного хранения состояния в таком виде.

Этот пейофф &mdash; возможность централизованно уведомлять
любые компоненты приложения о том, что с состоянием что-то
произошло. Это вводит слабую связь между компонентами приложения,
позволяя им не зависеть друг от друга. Это очень гибко.

Итак, как нам сделать так, чтобы компоненты приложения могли
подписываться на хранилище состояния и быть уведомлёнными о
всех изменениях?

```javascript
const StateModule = {
  state: {
    count: 0
  },

  // массив подписчиков-функций
  subscribers: [],

  mutations: {
    increment: state => state.count++
  },

  commit (mutation, payload) {
    this.mutations[mutation](this.state, payload)
  },

  // функция подписки на хранилище
  subscribe (callback) {
    this.subscribers.push(callback)
  }
}
```

Это не всё. Все подписчики должны быть уведомлены, когда с
состоянием происходит какая-то мутация.

```javascript
const StateModule = {
  state: {
    count: 0
  },

  subscribers: [],

  mutations: {
    increment: state => state.count++
  },

  commit (mutation, payload) {
    this.mutations[mutation](this.state, payload)

    // !!
    this.subscribers.forEach(subscriber => subscriber(this.state))
  },

  subscribe (callback) {
    this.subscribers.push(callback)
  }
}
```

Итак, теперь если где-то в коде будет вызвана функция
`StateModule.commit`, то все подписчики будут вызваны и в
качестве аргумента получат ссылку на свежую версию состояния.\
Круть.

Как это использовать?

Начнём с того, что весь код, связанный с модулем состояния, мы
уже написали, так что этот объект больше трогать не будем.

Давайте подумаем, как работает это игрушечное приложение в
контексте этой системы управления состоянием.

1. Пользователь нажимает на кнопку с плюсиком, тем самым
   выражая своё намерение увеличить значение счётчика на 1.
2. Внутри модуля состояния вызывается мутация `increment`.
3. Состояние изменяется, значение счётчика увеличивается на 1.
4. Все функции, подписанные на модуль состояния, вызываются,
   и им передаётся ссылка на новое состояние.
5. Функция перерисовки, подписанная на модуль состояния, будучи
   подписчиком, вызывается и меняет значение в метке, отображающей
   текущее значение счётчика.

Напишем это!

```javascript
// допустим, кнопка имеет id 'inc', а метка -- это div с id 'value'
const $button = document.querySelector('#inc')
const $label = document.querySelector('#value')

// Сначала добавим обработчик события нажатия кнопки, который
// будет производить выполнение нужной мутации на состоянии.
$button.addEventListener('click', () => StateModule.commit('increment'))

// Добавим функцию-слушателя, которая обновляет значение в счётчике
// при изменении состояния
StateModule.subscrube(state => $label.textContent = state.count)
```

Всё. Это (должно) будет работать.

Теперь хочется сразу поговорить о некоторых вещах, связанные с этим
паттерном управления состоянием.

Мутации &mdash; штука атомарная aka неделимая. Более того, они не
должны создавать сайд-эффектов, вроде XHR-запросов. Но в TODOApp,
например, может возникнуть ситуация, когда нужно отправить
XHR-запрос, а после его выполнения вызвать какую-нибудь мутацию.

Это, конечно, можно делать вне модуля управления состоянием,
но, пожалуй, самым правильным подходом будет введение новой
структурной единицы в этой архитектуре &mdash; _actions_.

Actions могут объединять в себе много мутаций, могут выполнять
асинхронные операции и создавать сайд-эффекты. Как и мутации,
они должны быть описаны в объекте состояния.

Как это выглядит?

```javascript
const StateModule = {
  // ...

  actions: {
    addTodo: (context, todoText) => {
        xhrRequest('POST', { text: todoText }, response => {
            if (!response.error) context.commit('addTodo', todoText)
        })
    }
  },

  dispatch (action, payload) {
    const context = {
        commit: this.commit.bind(this),
        state: this.state
    }

    this.actions[action](context, payload)
  },

  // ...
}
```

За применение action'ов на состояние, как можно видеть, отвечает
функция `dispatch`. Более того, экшен имеет доступ к функции
`commit` через первый параметр &mdash; `context`.

## 3. Заключительное слово.

Удачи. В этом задании придётся подумать над User Experience'ом
того, как у вас будет реализовано удаление и редактирование.
Постарайтесь это хорошо задизайнить.

Более того, обратите внимание на то, что каждая тудушка теперь
описывается не одной строкой, а объектом, содержащим строку и
булевый флаг:

```javascript
{
  text: 'Actual todo text',
  done: true // or false
}
```

[todos-solution]: https://github.com/am-cp-frontend/course/tree/master/homework/01-TODOApp/solution-realtime
